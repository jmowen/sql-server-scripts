/*
It would be nice to have the previous query as a viewâ€”in fact, as an INFORMATION_SCHEMA type of view. We have the KEY_COLUMN_USAGE view and REFERENTIAL_CONSTRAINTS view, but what we really need is a REFERENTIAL_CONSTRAINTS_COLUMN_USAGE view, one that would show at a glance the columns used by FK constraints. The following view definition will do the job:
/*
USE master
GO
IF OBJECT_ID('INFORMATION_SCHEMA.
REFERENTIAL_CONSTRAINTS_COLUMN_USAGE') IS NOT NULL
DROP VIEW INFORMATION_SCHEMA.
REFERENTIAL_CONSTRAINTS_COLUMN_USAGE
GO
CREATE VIEW INFORMATION_SCHEMA.
REFERENTIAL_CONSTRAINTS_COLUMN_USAGE
AS
*/
SELECT
KCU1.CONSTRAINT_CATALOG AS 'CONSTRAINT_CATALOG'
, KCU1.CONSTRAINT_SCHEMA AS 'CONSTRAINT_SCHEMA'
, KCU1.CONSTRAINT_NAME AS 'CONSTRAINT_NAME'
, KCU1.TABLE_CATALOG AS 'TABLE_CATALOG'
, KCU1.TABLE_SCHEMA AS 'TABLE_SCHEMA'
, KCU1.TABLE_NAME AS 'TABLE_NAME'
, KCU1.COLUMN_NAME AS 'COLUMN_NAME'
, KCU1.ORDINAL_POSITION AS 'ORDINAL_POSITION'
, KCU2.CONSTRAINT_CATALOG
AS 'UNIQUE_CONSTRAINT_CATALOG'
, KCU2.CONSTRAINT_SCHEMA
AS 'UNIQUE_CONSTRAINT_SCHEMA'
, KCU2.CONSTRAINT_NAME AS 'UNIQUE_CONSTRAINT_NAME'
, KCU2.TABLE_CATALOG AS 'UNIQUE_TABLE_CATALOG'
, KCU2.TABLE_SCHEMA AS 'UNIQUE_TABLE_SCHEMA'
, KCU2.TABLE_NAME AS 'UNIQUE_TABLE_NAME'
, KCU2.COLUMN_NAME AS 'UNIQUE_COLUMN_NAME'
FROM INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS RC
JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE KCU1
ON KCU1.CONSTRAINT_CATALOG = RC.CONSTRAINT_CATALOG
AND KCU1.CONSTRAINT_SCHEMA =
RC.CONSTRAINT_SCHEMA
AND KCU1.CONSTRAINT_NAME = RC.CONSTRAINT_NAME
JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE KCU2
ON KCU2.CONSTRAINT_CATALOG =
RC.UNIQUE_CONSTRAINT_CATALOG
AND KCU2.CONSTRAINT_SCHEMA =
RC.UNIQUE_CONSTRAINT_SCHEMA
AND KCU2.CONSTRAINT_NAME =
RC.UNIQUE_CONSTRAINT_NAME
WHERE KCU1.ORDINAL_POSITION = KCU2.ORDINAL_POSITION
